<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Auto Quiz from PDF (Moderate Difficulty)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b0c0f;
      --panel: #111318;
      --panel-2: #151922;
      --text: #e9ecf1;
      --muted: #a9b1bd;
      --primary: #4c8bf5;
      --primary-2: #2f74f0;
      --accent: #22c55e;
      --danger: #ef4444;
      --warning: #f59e0b;
      --border: #273043;
      --shadow: 0 10px 24px rgba(0,0,0,.35);
      --radius: 12px;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f7fb;
        --panel: #ffffff;
        --panel-2: #f8fafc;
        --text: #0e1116;
        --muted: #495467;
        --primary: #2563eb;
        --primary-2: #1d4ed8;
        --accent: #16a34a;
        --danger: #dc2626;
        --warning: #d97706;
        --border: #e5e7eb;
        --shadow: 0 10px 24px rgba(16, 24, 40, .08);
      }
    }
    * { box-sizing: border-box; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      margin: 0;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 110% -10%, rgba(76,139,245,.15), transparent 40%),
        radial-gradient(900px 500px at -10% -10%, rgba(34,197,94,.12), transparent 45%),
        var(--bg);
      min-height: 100dvh;
    }
    .wrap { max-width: 920px; margin: 36px auto; padding: 0 20px 24px; }
    .header {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
    }
    .header h1 { margin: 0 0 8px; font-size: 22px; font-weight: 700; letter-spacing: .2px; }
    .sub { margin: 0; color: var(--muted); font-size: 14px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-top: 14px; }
    input[type="file"] {
      padding: 10px 12px; border: 1px dashed var(--border); border-radius: 10px; background: transparent; color: var(--text); cursor: pointer;
    }
    input[type="number"] {
      width: 110px; padding: 10px 12px; border: 1px solid var(--border); border-radius: 10px; background: var(--panel-2); color: var(--text); outline: none;
    }
    input[type="number"]:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 4px color-mix(in srgb, var(--primary) 20%, transparent);
    }
    .btn {
      padding: 10px 14px; border-radius: 10px; border: 1px solid var(--border);
      background: var(--panel-2); color: var(--text); cursor: pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease; user-select: none;
    }
    .btn:hover { background: color-mix(in srgb, var(--panel-2) 80%, var(--text) 3%); }
    .btn:active { transform: translateY(1px); }
    .btn[disabled] { opacity: .6; cursor: not-allowed; }
    .btn.primary {
      background: linear-gradient(180deg, var(--primary), var(--primary-2));
      color: #fff;
      border: 1px solid color-mix(in srgb, var(--primary-2) 80%, black 10%);
      box-shadow: 0 4px 12px color-mix(in srgb, var(--primary) 40%, transparent);
    }
    .btn.primary:hover { filter: brightness(1.05); }
    .btn.ghost { background: transparent; }
    .status { font-size: 14px; color: var(--muted); display: inline-flex; align-items: center; gap: 8px; }
    .status::before { content: ""; width: 8px; height: 8px; border-radius: 50%; background: var(--primary); box-shadow: 0 0 0 6px color-mix(in srgb, var(--primary) 25%, transparent); }
    .panel {
      margin-top: 16px; background: var(--panel); border: 1px solid var(--border);
      border-radius: var(--radius); box-shadow: var(--shadow); padding: 16px;
    }
    .quiz { display: none; }
    .question {
      border: 1px solid var(--border); border-radius: 12px; padding: 14px;
      background: color-mix(in srgb, var(--panel) 85%, var(--panel-2) 15%);
      transition: border-color .15s ease, transform .05s ease, background .2s ease;
    }
    .question + .question { margin-top: 12px; }
    .question:hover { border-color: color-mix(in srgb, var(--primary) 40%, var(--border)); }
    .question h3 { margin: 0 0 10px; font-size: 16px; line-height: 1.4; }
    fieldset { border: none; padding: 0; margin: 0; }
    .options { display: grid; gap: 8px; }
    .choice {
      display: grid; grid-template-columns: 24px 1fr; gap: 10px; align-items: start;
      padding: 10px 12px; border: 1px solid var(--border); border-radius: 10px; background: var(--panel-2);
      cursor: pointer; transition: border-color .15s ease, background .15s ease;
    }
    .choice:hover { border-color: color-mix(in srgb, var(--primary) 35%, var(--border)); }
    .choice input { margin-top: 2px; width: 18px; height: 18px; accent-color: var(--primary); }
    .choice span { line-height: 1.35; }
    .footer {
      position: sticky; bottom: 0; background: linear-gradient(180deg, transparent, var(--bg) 40%);
      padding-top: 8px; margin-top: 16px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
    }
    .score {
      font-weight: 700; padding: 6px 10px; border-radius: 999px;
      background: color-mix(in srgb, var(--panel) 80%, var(--panel-2)); border: 1px solid var(--border);
    }
    .hint { font-size: 13px; color: var(--muted); margin-top: 8px; }
    .feedback { margin-top: 8px; font-size: 14px; }
    .chip {
      display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px;
      border: 1px solid var(--border); background: var(--panel-2);
    }
    .chip.correct { color: var(--accent); border-color: color-mix(in srgb, var(--accent) 40%, var(--border)); }
    .chip.incorrect { color: var(--danger); border-color: color-mix(in srgb, var(--danger) 40%, var(--border)); }
    .chip.unanswered { color: var(--warning); border-color: color-mix(in srgb, var(--warning) 40%, var(--border)); }
    .explanation {
      margin-top: 8px; padding: 10px 12px; border: 1px dashed var(--border);
      border-radius: 10px; background: color-mix(in srgb, var(--panel) 92%, var(--panel-2)); color: var(--muted);
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js" defer></script>
  <script>
    (function ensurePdfJs() {
      const check = () => {
        if (window.pdfjsLib) return;
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js';
        s.defer = true;
        document.head.appendChild(s);
      };
      setTimeout(check, 120);
    })();
  </script>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1>Upload a PDF to Generate a Quiz</h1>
      <p class="sub">Moderate-difficulty MCQs created from your document’s key concepts and statements.</p>
      <div class="row">
        <input id="pdfInput" type="file" accept="application/pdf" />
        <label for="numQ" class="sub">Questions</label>
        <input id="numQ" type="number" min="3" max="50" value="10" />
        <button id="parseBtn" class="btn primary" disabled>Generate Quiz</button>
        <span id="status" class="status">Select a text-based PDF to begin.</span>
      </div>
    </div>

    <div class="panel quiz" id="quizContainer">
      <div id="questions"></div>
      <div class="footer">
        <button id="submitBtn" class="btn primary">Submit</button>
        <button id="regenerateBtn" class="btn">Regenerate</button>
        <button id="resetBtn" class="btn ghost">Reset</button>
        <span id="score" class="score"></span>
      </div>
      <div class="hint">Tip: Regenerate to get a different mix of cloze, definition, and true‑about questions.</div>
    </div>
  </div>

  <script>
    const pdfInput = document.getElementById('pdfInput');
    const parseBtn = document.getElementById('parseBtn');
    const statusEl = document.getElementById('status');
    const quizEl = document.getElementById('quizContainer');
    const questionsEl = document.getElementById('questions');
    const submitBtn = document.getElementById('submitBtn');
    const regenerateBtn = document.getElementById('regenerateBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');
    const numQInput = document.getElementById('numQ');

    let PDFJS = null;
    let fullDocText = '';
    let latestQuestions = [];

    function initPdfJsOrShowError() {
      PDFJS = window['pdfjsLib'] || null;
      if (!PDFJS) {
        statusEl.textContent = 'Failed to load PDF.js. Check your internet or try another network.';
        parseBtn.disabled = true;
        return false;
      }
      PDFJS.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js';
      return true;
    }

    pdfInput.addEventListener('change', () => {
      parseBtn.disabled = !pdfInput.files?.length;
      statusEl.textContent = pdfInput.files?.length ? 'PDF selected. Click "Generate Quiz".' : 'Select a text-based PDF to begin.';
      scoreEl.textContent = '';
      questionsEl.innerHTML = '';
      quizEl.style.display = 'none';
      fullDocText = '';
      latestQuestions = [];
    });

    parseBtn.addEventListener('click', async () => {
      if (!initPdfJsOrShowError()) return;
      const file = pdfInput.files?.[0];
      if (!file) return;

      statusEl.textContent = 'Reading PDF...';
      parseBtn.disabled = true;

      try {
        const arrayBuffer = await file.arrayBuffer();
        const loadingTask = PDFJS.getDocument({ data: arrayBuffer });
        loadingTask.onPassword = (updatePassword, reason) => {
          const msg = reason === PDFJS.PasswordResponses.NEED_PASSWORD ? 'This PDF is password-protected. Enter password:' : 'Incorrect password. Try again:';
          const pwd = window.prompt(msg, '');
          if (pwd == null) throw new Error('Password required but not provided.');
          updatePassword(pwd);
        };

        const doc = await loadingTask.promise;
        statusEl.textContent = `Extracting text from ${doc.numPages} page(s)...`;

        const pageTexts = [];
        for (let pageNum = 1; pageNum <= doc.numPages; pageNum++) {
          const page = await doc.getPage(pageNum);
          const content = await page.getTextContent();
          const text = content.items.map(item => item.str).filter(Boolean).join(' ');
          pageTexts.push(text);
          statusEl.textContent = `Extracting text... ${pageNum}/${doc.numPages}`;
        }

        fullDocText = normalizeText(pageTexts.join('\n\n'));

        if (wordCount(fullDocText) < 80) {
          statusEl.textContent = 'Document text appears too short. Use a richer, text-based PDF (not scanned).';
          parseBtn.disabled = false;
          return;
        }

        const numQuestions = clamp(parseInt(numQInput.value, 10) || 10, 3, 50);
        latestQuestions = generateModerateQuestions(fullDocText, numQuestions);

        if (latestQuestions.length === 0) {
          statusEl.textContent = 'Could not generate questions. Try reducing question count or a different section of text.';
          parseBtn.disabled = false;
          return;
        }

        renderQuiz(latestQuestions);
        quizEl.style.display = 'block';
        statusEl.textContent = `Generated ${latestQuestions.length} moderate question(s).`;
      } catch (err) {
        console.error(err);
        statusEl.textContent = `Failed to read PDF: ${err?.message || 'Unknown error'}`;
      } finally {
        parseBtn.disabled = false;
      }
    });

    regenerateBtn.addEventListener('click', () => {
      if (!fullDocText) return;
      const numQuestions = clamp(parseInt(numQInput.value, 10) || 10, 3, 50);
      latestQuestions = generateModerateQuestions(fullDocText, numQuestions, { shuffleSeed: Date.now() });
      renderQuiz(latestQuestions);
      scoreEl.textContent = '';
      statusEl.textContent = `Regenerated ${latestQuestions.length} question(s).`;
    });

    submitBtn.addEventListener('click', () => {
      const blocks = [...document.querySelectorAll('.question')];
      let score = 0;
      let unanswered = 0;

      blocks.forEach((block, idx) => {
        block.querySelectorAll('.feedback').forEach(el => el.remove());
        const name = `q${idx}`;
        const selected = document.querySelector(`input[name="${name}"]:checked`);
        const correctIndex = Number(block.dataset.correctIndex);
        const q = latestQuestions[idx];

        const chip = document.createElement('div');
        chip.className = 'feedback';

        if (!selected) {
          unanswered++;
          chip.innerHTML = `<span class="chip unanswered">Unanswered</span> <span class="chip">Correct: ${q.options[correctIndex]}</span>` + (q.explanation ? `<div class="explanation">${q.explanation}</div>` : '');
          block.appendChild(chip);
          return;
        }

        const chosenIndex = Number(selected.value);
        if (chosenIndex === correctIndex) {
          score++;
          chip.innerHTML = `<span class="chip correct">Correct</span>`;
        } else {
          chip.innerHTML = `<span class="chip incorrect">Incorrect</span> <span class="chip">Correct: ${q.options[correctIndex]}</span>` + (q.explanation ? `<div class="explanation">${q.explanation}</div>` : '');
        }
        block.appendChild(chip);
      });

      scoreEl.textContent = `Score: ${score} / ${blocks.length} (Unanswered: ${unanswered})`;
    });

    resetBtn.addEventListener('click', () => {
      document.querySelectorAll('input[type="radio"]').forEach(r => r.checked = false);
      document.querySelectorAll('.feedback').forEach(el => el.remove());
      scoreEl.textContent = '';
    });

    function renderQuiz(questions) {
      questionsEl.innerHTML = '';
      questions.forEach((q, idx) => {
        const container = document.createElement('div');
        container.className = 'question';
        container.dataset.correctIndex = String(q.correctIndex);

        const title = document.createElement('h3');
        title.textContent = q.prompt; // no numbering
        container.appendChild(title);

        const fieldset = document.createElement('fieldset');
        const optionsDiv = document.createElement('div');
        optionsDiv.className = 'options';

        q.options.forEach((opt, optIdx) => {
          const id = `q${idx}_opt${optIdx}`;
          const label = document.createElement('label');
          label.className = 'choice';
          label.setAttribute('for', id);

          const input = document.createElement('input');
          input.type = 'radio';
          input.name = `q${idx}`;
          input.id = id;
          input.value = String(optIdx);

          const text = document.createElement('span');
          text.textContent = opt;

          label.appendChild(input);
          label.appendChild(text);
          optionsDiv.appendChild(label);
        });

        fieldset.appendChild(optionsDiv);
        container.appendChild(fieldset);
        questionsEl.appendChild(container);
      });
      scoreEl.textContent = '';
      document.querySelectorAll('.feedback').forEach(el => el.remove());
    }

    // ---------- Context helpers ----------
    function buildContextSnippet(sentences, idx, term, maxLen = 240) {
      const parts = [];
      if (idx > 0) parts.push(sentences[idx - 1]);
      parts.push(sentences[idx]);
      if (idx < sentences.length - 1) parts.push(sentences[idx + 1]);
      const full = parts.join(' ').replace(/\s+/g, ' ').trim();
      let snippet = full;
      if (snippet.length > maxLen) {
        const rx = new RegExp('\\b' + escapeRegExp(term) + '\\b', 'i');
        const m = snippet.match(rx);
        if (m && m.index !== undefined) {
          const center = m.index + m[0].length / 2;
          const start = Math.max(0, Math.floor(center - maxLen / 2));
          snippet = (start > 0 ? '… ' : '') + snippet.slice(start, start + maxLen).trim() + (start + maxLen < full.length ? ' …' : '');
        } else {
          snippet = snippet.slice(0, maxLen).trim() + ' …';
        }
      }
      return highlightTerm(snippet, term);
    }
    function highlightTerm(text, term) {
      const rx = new RegExp('(\\b' + escapeRegExp(term) + '\\b)', 'ig');
      return text.replace(rx, '“$1”');
    }

    // -------------------
    // Moderate question generation
    // -------------------
    function normalizeText(text) {
      return text
        .replace(/\r/g, ' ')
        .replace(/\u00a0/g, ' ')
        .replace(/[ \t]+/g, ' ')
        .replace(/\s+\n/g, '\n')
        .replace(/\n\s+/g, '\n')
        .trim();
    }
    function wordCount(s) { return (s || '').trim().split(/\s+/).filter(Boolean).length; }
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
    function sentenceSplit(text) {
      return text
        .replace(/([.?!])\s+(?=[A-Z(])/g, '$1|')
        .split('|')
        .map(s => s.replace(/\s+/g, ' ').trim())
        .filter(s => s.length > 0);
    }
    const STOPWORDS = new Set([
      'the','a','an','and','or','but','if','then','else','for','to','of','in','on','by','with','as','at','from','that','this','these','those','it','its','is','are','was','were','be','been','being','which','who','whom','whose','what','when','where','why','how','not','so','into','we','you','they','he','she','i','their','our','your','his','her','them','us','me',
      'can','could','should','would','may','might','will','shall','do','does','did','done','have','has','had','more','most','many','much','very','such','other','than','also','because','however','therefore','thus'
    ]);
    function tokenize(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s\-']/g, ' ')
        .split(/\s+/)
        .filter(Boolean);
    }
    function extractTopTermsWithPhrases(text, maxTerms = 400) {
      const tokens = tokenize(text);
      const unigrams = new Map(), bigrams = new Map(), trigrams = new Map();
      const isGood = t => !STOPWORDS.has(t) && /[a-z]/.test(t) && t.length >= 3;
      for (let i = 0; i < tokens.length; i++) {
        const t1 = tokens[i];
        if (isGood(t1)) unigrams.set(t1, (unigrams.get(t1) || 0) + 1);
        const t2 = tokens[i + 1];
        if (t2 && isGood(t1) && isGood(t2)) bigrams.set(`${t1} ${t2}`, (bigrams.get(`${t1} ${t2}`) || 0) + 1);
        const t3 = tokens[i + 2];
        if (t2 && t3 && isGood(t1) && isGood(t2) && isGood(t3)) trigrams.set(`${t1} ${t2} ${t3}`, (trigrams.get(`${t1} ${t2} ${t3}`) || 0) + 1);
      }
      const scored = [];
      for (const [term, c] of unigrams) scored.push({ term, count: c, len: 1, score: c });
      for (const [term, c] of bigrams) scored.push({ term, count: c, len: 2, score: c * 1.6 });
      for (const [term, c] of trigrams) scored.push({ term, count: c, len: 3, score: c * 2.2 });
      scored.sort((a, b) => b.score - a.score);
      const taken = new Set(); const result = [];
      for (const t of scored) {
        const key = t.term;
        if ([...taken].some(x => x.includes(key) || key.includes(x))) continue;
        taken.add(key); result.push(t);
        if (result.length >= maxTerms) break;
      }
      return result;
    }
    function pickInformativeSentences(sentences) {
      const scored = sentences.map((s, idx) => {
        const wc = wordCount(s);
        const hasComma = s.includes(',');
        const hasLink = /\b(therefore|however|because|whereas|although|while|thus|hence|consequently|in contrast|for example)\b/i.test(s);
        let score = 0;
        if (wc >= 12 && wc <= 35) score += 2; else if (wc >= 8 && wc <= 45) score += 1;
        if (hasComma) score += 1; if (hasLink) score += 1.2; if (/[;:]/.test(s)) score += 0.5;
        return { s, idx, wc, score };
      });
      scored.sort((a, b) => b.score - a.score);
      return scored;
    }
    function seededRandom(seed = 0xA1B2C3D) {
      let x = (seed >>> 0) || 0x9E3779B9;
      return function() { x ^= x << 13; x >>>= 0; x ^= x >>> 17; x >>>= 0; x ^= x << 5; x >>>= 0; return ((x >>> 0) / 0xFFFFFFFF); };
    }
    function shuffleInPlace(arr, rng = Math.random) {
      for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(rng() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; }
      return arr;
    }
    function jaccardCharacters(a, b) {
      const sa = new Set(a.split('')); const sb = new Set(b.split(''));
      const inter = new Set([...sa].filter(x => sb.has(x))); const union = new Set([...sa, ...sb]);
      return inter.size / Math.max(1, union.size);
    }
    function titleCase(s) { return s.replace(/\b([a-z])/g, (_, c) => c.toUpperCase()); }
    function escapeRegExp(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

    function chooseTargets(sentences, topTerms, want, rng) {
      const informative = pickInformativeSentences(sentences);
      const termSet = new Set(topTerms.map(t => t.term));
      const selected = [], usedSentIdx = new Set(), usedTerms = new Set();
      for (const item of informative) {
        if (selected.length >= want * 2) break;
        if (usedSentIdx.has(item.idx)) continue;
        const s = item.s; const tokens = tokenize(s); const candidates = [];
        for (let len = 3; len >= 1; len--) {
          for (let i = 0; i <= tokens.length - len; i++) {
            const phrase = tokens.slice(i, i + len).join(' ');
            if (termSet.has(phrase) && phrase.length >= 4 && !/^\d+$/.test(phrase)) candidates.push({ phrase, len });
          }
          if (candidates.length) break;
        }
        if (!candidates.length) continue;
        let chosen = null;
        for (const cand of candidates) { if (usedTerms.has(cand.phrase)) continue; chosen = cand; break; }
        if (!chosen) continue;
        selected.push({ idx: item.idx, sentence: s, answer: chosen.phrase });
        usedSentIdx.add(item.idx); usedTerms.add(chosen.phrase);
      }
      return selected.slice(0, want);
    }

    function nearestSentences(sentences, idx, radius = 2) {
      const res = [];
      for (let i = Math.max(0, idx - radius); i <= Math.min(sentences.length - 1, idx + radius); i++) {
        if (i !== idx) res.push({ s: sentences[i], idx: i });
      }
      return res;
    }

    function buildDistractors(answer, pool, sentences, anchorIdx, k, rng) {
      const answerLc = answer.toLowerCase(); const answerLen = answerLc.length;
      const nearbyText = nearestSentences(sentences, anchorIdx, 2).map(x => x.s).join(' ');
      const nearbyTerms = extractTopTermsWithPhrases(nearbyText, 60).map(t => t.term);
      const allCandidates = [...new Set([...nearbyTerms, ...pool])];
      const candidates = allCandidates
        .filter(t => t.toLowerCase() !== answerLc)
        .filter(t => Math.abs(t.length - answerLen) <= 5)
        .filter(t => jaccardCharacters(t.toLowerCase(), answerLc) < 0.65)
        .filter(t => !STOPWORDS.has(t.toLowerCase()))
        .filter(t => !/^\d+$/.test(t))
        .slice();
      shuffleInPlace(candidates, rng);
      const unique = [];
      for (const c of candidates) {
        if (unique.length >= k) break;
        if (unique.some(u => jaccardCharacters(u.toLowerCase(), c.toLowerCase()) >= 0.65)) continue;
        unique.push(c);
      }
      return unique.map(titleCase);
    }

    function shuffleAndLabel(arr, rng) {
      const copy = arr.slice(); shuffleInPlace(copy, rng);
      return copy.map((text, i) => ({ label: String.fromCharCode(65 + i), text }));
    }

    function makeClozeQuestion(target, sentences, topPool, rng) {
      const answer = target.answer;
      const rx = new RegExp('\\b' + escapeRegExp(answer) + '\\b', 'i');
      if (!rx.test(target.sentence)) return null;
      const prompt = target.sentence.replace(rx, '_____');
      if (wordCount(prompt) < 10) return null;
      const distractors = buildDistractors(answer, topPool, sentences, target.idx, 3, rng);
      if (distractors.length < 3) return null;
      const optionsRaw = shuffleAndLabel([titleCase(answer), ...distractors], rng);
      const correctIndex = optionsRaw.findIndex(o => o.text.toLowerCase() === titleCase(answer).toLowerCase());
      return {
        type: 'cloze',
        prompt,
        options: optionsRaw.map(o => o.label + ') ' + o.text),
        correctIndex,
        explanation: `Context: ${buildContextSnippet(sentences, target.idx, answer)}`
      };
    }

    function definitionPattern(sentence, answer) {
      const rx = new RegExp(`\\b${escapeRegExp(answer)}\\b\\s+(is|are|refers to|means|denotes|involves|consists of|can be defined as)\\s+([^.;:]+)`, 'i');
      const m = sentence.match(rx);
      if (m) return `${titleCase(answer)} ${m[1]} ${m[2].trim()}.`;
      return null;
    }

    function makeDefinitionQuestion(target, sentences, topPool, rng) {
      const answer = titleCase(target.answer);
      const candSentences = [target.sentence, ...nearestSentences(sentences, target.idx, 1).map(x => x.s)];
      let defText = null;
      for (const s of candSentences) { defText = definitionPattern(s, target.answer); if (defText) break; }
      if (!defText) return null;
      const distractors = buildDistractors(target.answer, topPool, sentences, target.idx, 3, rng)
        .map(term => `${term} is ${generateGenericDefinitionTail(term)}`);
      if (distractors.length < 3) return null;
      const optionsRaw = shuffleAndLabel([defText, ...distractors], rng);
      const correctIndex = optionsRaw.findIndex(o => o.text === defText);
      return {
        type: 'definition',
        prompt: `Which option best defines ${answer}?`,
        options: optionsRaw.map(o => o.label + ') ' + o.text),
        correctIndex,
        explanation: `Context: ${buildContextSnippet(sentences, target.idx, target.answer)}`
      };
    }

    function makeTrueAboutQuestion(target, sentences, topPool, rng) {
      const answer = titleCase(target.answer);
      const s = target.sentence; if (wordCount(s) < 10) return null;
      const trueStmt = s.includes(answer) ? s : s.replace(new RegExp('\\b' + escapeRegExp(target.answer) + '\\b', 'i'), answer);
      const falseStmts = [];
      const distractorTerms = buildDistractors(target.answer, topPool, sentences, target.idx, 6, rng);
      for (const dt of distractorTerms.slice(0, 6)) {
        const wrong = trueStmt.replace(new RegExp('\\b' + escapeRegExp(answer) + '\\b', 'i'), dt);
        if (wrong !== trueStmt && wordCount(wrong) >= 10) falseStmts.push(wrong);
        if (falseStmts.length >= 3) break;
      }
      if (falseStmts.length < 3) return null;
      const optionsRaw = shuffleAndLabel([trueStmt, ...falseStmts], rng);
      const correctIndex = optionsRaw.findIndex(o => o.text === trueStmt);
      return {
        type: 'trueabout',
        prompt: `Which of the following is true about ${answer}?`,
        options: optionsRaw.map(o => o.label + ') ' + o.text),
        correctIndex,
        explanation: `Context: ${buildContextSnippet(sentences, target.idx, target.answer)}`
      };
    }

    function generateGenericDefinitionTail(term) {
      const tails = [
        'primarily concerned with peripheral aspects unrelated to core concepts',
        'a general approach focusing on adjacent but distinct principles',
        'characterized by features that are context-dependent rather than essential',
        'commonly associated with outcomes rather than underlying mechanisms'
      ];
      return tails[Math.floor(Math.random() * tails.length)];
    }

    function generateModerateQuestions(text, numQuestions, { shuffleSeed } = {}) {
      const rng = shuffleSeed ? seededRandom(shuffleSeed) : seededRandom();
      const sentences = sentenceSplit(text);
      const topTerms = extractTopTermsWithPhrases(text, 400);
      const topPool = topTerms.map(t => t.term).slice(0, 250);
      const rawTargets = chooseTargets(sentences, topTerms, numQuestions * 3, rng);
      if (rawTargets.length === 0) return [];
      const questions = []; const usedPrompts = new Set();
      const wantCloze = Math.max(1, Math.floor(numQuestions * 0.4));
      const wantDef = Math.max(1, Math.floor(numQuestions * 0.3));
      const wantTrue = Math.max(1, Math.floor(numQuestions * 0.3));
      shuffleInPlace(rawTargets, rng);

      function tryAdd(q) {
        if (!q) return false;
        if (usedPrompts.has(q.prompt)) return false;
        if (!q.options || q.options.length !== 4) return false;
        usedPrompts.add(q.prompt); questions.push(q); return true;
      }

      for (const t of rawTargets) { if (questions.filter(x => x.type === 'cloze').length >= wantCloze) break; tryAdd(makeClozeQuestion(t, sentences, topPool, rng)); }
      for (const t of rawTargets) { if (questions.filter(x => x.type === 'definition').length >= wantDef) break; tryAdd(makeDefinitionQuestion(t, sentences, topPool, rng)); }
      for (const t of rawTargets) { if (questions.filter(x => x.type === 'trueabout').length >= wantTrue) break; tryAdd(makeTrueAboutQuestion(t, sentences, topPool, rng)); }

      for (const t of rawTargets) {
        if (questions.length >= numQuestions) break;
        const attempts = [
          makeClozeQuestion(t, sentences, topPool, rng),
          makeTrueAboutQuestion(t, sentences, topPool, rng),
          makeDefinitionQuestion(t, sentences, topPool, rng)
        ];
        for (const q of attempts) {
          if (questions.length >= numQuestions) break;
          tryAdd(q);
        }
      }
      return questions.slice(0, numQuestions);
    }
  </script>
</body>
</html>
